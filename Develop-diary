解释一下 BufferTrigger 对应的消费者方法 consumeMessage() 中的逻辑，如下：
首先，将聚合后的这批消息 List<String> 转换为 List<CountFollowUnfollowMqDTO> 实体类集合；
按目标用户 ID 进行分组，因为这一批消息中，可能关注、取关的目标用户不一样；
对分组完成后的 Map 进行循环；
循环 Map 的 Value, 分别获取其操作类型：
如果为关注操作，粉丝数 +1；
如果为取关操作，粉丝数 -1
累积计算完成后，存入到 Map<Long, Integer> 中，Key 为目标用户 ID; Value 为计数值；
循环 Map<Long, Integer> ， 构建 Redis Key, 判断缓存是否存在：
若存在，则执行更新操作；
若不存在，说明缓存过期了，或者暂未初始化，则无需更新 Redis;
最后，发送 MQ, 在对应的消费者中，将计数数据存入数据库中；
存库这一步，单独再发送一个 MQ, 主要是考虑的是，即使进行了聚合，流量削峰了，数据库可能依然承受不住，独立一个消费者出来处理，可以单独进行令牌桶削峰，进一步对流量进行控制，防止打垮数据库。
