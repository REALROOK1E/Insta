解释一下 BufferTrigger 对应的消费者方法 consumeMessage() 中的逻辑，如下：
首先，将聚合后的这批消息 List<String> 转换为 List<CountFollowUnfollowMqDTO> 实体类集合；
按目标用户 ID 进行分组，因为这一批消息中，可能关注、取关的目标用户不一样；
对分组完成后的 Map 进行循环；
循环 Map 的 Value, 分别获取其操作类型：
如果为关注操作，粉丝数 +1；
如果为取关操作，粉丝数 -1
累积计算完成后，存入到 Map<Long, Integer> 中，Key 为目标用户 ID; Value 为计数值；
循环 Map<Long, Integer> ， 构建 Redis Key, 判断缓存是否存在：
若存在，则执行更新操作；
若不存在，说明缓存过期了，或者暂未初始化，则无需更新 Redis;
最后，发送 MQ, 在对应的消费者中，将计数数据存入数据库中；
存库这一步，单独再发送一个 MQ, 主要是考虑的是，即使进行了聚合，流量削峰了，数据库可能依然承受不住，独立一个消费者出来处理，可以单独进行令牌桶削峰，进一步对流量进行控制，防止打垮数据库。

解释一下消费者中的处理逻辑：

关注数和粉丝数计数场景不同，单个用户无法短时间内关注大量用户，所以无需聚合，直接对 Redis 中的 Hash 关注数字段进行 +1 或 -1 操作即可。

将消息体 body 解析为 CountFollowUnfollowMqDTO 实体类；
判断 Hash 是否存在；
若存在，根据操作类型，对 Hash 中的 followingTotal 字段进行加减操作，关注 +1， 取关 -1;
若不存在，则不执行更新操作；
发送关注数入库 MQ， 在对应的消费者类中，将关注数更新到数据库中；

如上图所示，当执行了 点赞 -> 取消点赞 -> 点赞 操作后，用户 A 无法再对笔记 1 进行点赞了。


误判处理方案
为了笔记能够正常被点赞，我们可以采用 Bloom 过滤器校验 + ZSet 校验 + 数据库校验 方案。
处理流程如下：
当查询布隆过滤器，校验笔记是否被点赞时，若返回已点赞，由于存在误判，需要进一步校验；
查询当前用户的 ZSET 笔记点赞列表（最多只有 100 条），是否包含目标笔记，若包含，说明目标笔记已经被点赞；
若不存在，还需查询数据库，进一步确认笔记是否被点赞，若数据库中存在点赞记录，说明目标笔记已经被点赞；
若数据库中也没有点赞记录，才能继续执行后续的点赞流程；
