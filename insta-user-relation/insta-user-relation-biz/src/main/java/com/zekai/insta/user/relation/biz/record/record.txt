RelationServiceImpl 开发笔记

1. 概述

`RelationServiceImpl` 是用户关系服务中的核心组件，主要负责处理用户关注其他用户的业务逻辑。它基于 Spring Boot 框架，并结合了 MyBatis、Redis 和 Lua 脚本，旨在实现高性能和强一致性的用户关系管理。

2. 核心设计思路

2.1. 缓存优先策略（Cache-Aside）

- 读操作：
    - 首先，尝试从 Redis 缓存中获取用户的关注列表。
    - 如果缓存命中（Redis 中存在该用户的关注列表），则直接返回缓存数据，避免访问数据库，提高响应速度。
    - 如果缓存未命中（Redis 中不存在该用户的关注列表），则从数据库中加载用户的关注关系数据，并将这些数据同步到 Redis 缓存中，以便后续访问。
- 写操作：
    - 优先更新 Redis 缓存，保证最新的关注关系能够快速被访问到。
    - TODO：目前的代码只实现了 Redis 缓存的更新，数据库的更新尚未实现。理想情况下，应该采用异步方式更新数据库，例如通过消息队列（MQ）来解耦缓存更新和数据库更新操作，提高系统吞吐量。

2.2. 原子性保证（Lua 脚本）

- 背景：在高并发场景下，多个线程同时修改 Redis 中的数据可能会导致数据不一致。例如，一个线程在检查用户关注数量未达到上限后，准备添加新的关注关系时，另一个线程可能已经添加了新的关注关系，导致第一个线程添加的关注关系丢失。
- 解决方案：使用 Lua 脚本来保证 Redis 操作的原子性。Lua 脚本可以将多个 Redis 命令打包成一个原子操作，从而避免并发问题。
- Lua 脚本的功能：
    - 检查用户的关注数量是否达到上限。
    - 检查用户是否已经关注了目标用户。
    - 如果以上两个条件都满足，则将新的关注关系添加到 Redis 缓存中。

2.3. 数据结构选择（ZSET 有序集合）

- 为什么选择 ZSET：
    - ZSET 是一种有序集合，它可以为每个成员关联一个分数（score），并根据分数对成员进行排序。
    - 在用户关系服务中，可以使用 ZSET 存储用户的关注列表，其中：
        - Score：存储关注的时间戳，用于按时间顺序显示用户的关注列表。
        - Member：存储被关注用户的 ID，用于快速判断用户是否已经关注了目标用户。
- ZSET 的优势：
    - 可以快速获取用户的关注数量（通过 `ZCARD` 命令，时间复杂度为 O(1)）。
    - 可以快速判断用户是否已经关注了目标用户（通过 `ZSCORE` 命令，时间复杂度为 O(log N)）。
    - 可以按关注时间排序用户的关注列表。

2.4. 缓存过期策略（随机过期时间）

- 目的：防止缓存雪崩。
- 缓存雪崩：指在同一时刻，大量的缓存同时过期，导致所有的请求都直接访问数据库，从而使数据库压力过大，甚至崩溃。
- 解决方案：为每个缓存设置一个随机的过期时间，避免大量的缓存同时过期。
- 具体实现：
    - 设置缓存的过期时间为 1-2 天的随机值。
    - TODO：可以根据用户类型（例如，大 V 用户）设置不同的过期时间。对于大 V 用户，可以设置更长的过期时间，甚至不设置过期时间，因为他们的关注列表通常不会发生变化。

2.5. 多层校验机制

- 目的：确保数据的有效性和一致性。
- 校验内容：
    - 用户不能关注自己。
    - 被关注的用户必须存在。
    - 用户的关注数量不能超过上限（例如，1000 人）。
    - 用户不能重复关注同一个用户。

3. 核心方法详解

3.1. `follow` 方法

`follow` 方法是实现用户关注功能的核心方法。

1.  参数校验：
    - 首先，对请求参数进行校验，确保用户不能关注自己，并且被关注的用户是存在的。
2.  构建 Redis Key：
    - 根据当前用户的 ID，构建 Redis 中存储用户关注列表的 Key。
3.  执行 Lua 脚本（`follow_check_and_add.lua`）：
    - 调用 `redisTemplate.execute` 方法执行 Lua 脚本。
    - `follow_check_and_add.lua` 脚本负责检查用户的关注数量是否达到上限、用户是否已经关注了目标用户，以及将新的关注关系添加到 Redis 缓存中。
4.  处理 Lua 脚本的返回结果：
    - 根据 Lua 脚本的返回结果，判断关注操作是否成功。
    - 如果 Lua 脚本返回 `FOLLOW_LIMIT`，则表示用户的关注数量已达到上限，抛出 `BizException` 异常。
    - 如果 Lua 脚本返回 `ALREADY_FOLLOWED`，则表示用户已经关注了目标用户，抛出 `BizException` 异常。
    - 如果 Lua 脚本返回 `ZSET_NOT_EXIST`，则表示 Redis 中不存在该用户的关注列表，需要从数据库中加载数据并同步到 Redis 缓存中。
5.  处理 ZSET 不存在的情况：
    - 从数据库中查询当前用户的关注关系记录。
    - 如果数据库中没有记录，则直接将新的关注关系添加到 Redis 缓存中，并设置过期时间。
    - 如果数据库中有记录，则使用 `follow_batch_add_and_expire.lua` 脚本批量将数据库中的关注关系数据同步到 Redis 缓存中，并设置过期时间。
    - 再次调用 `follow_check_and_add.lua` 脚本，将最新的关注关系添加到 Redis 缓存中。
6.  TODO：完善后续逻辑：
    - 将关注关系写入数据库。
    - 发送消息队列通知其他服务，例如通知被关注用户。

3.2. `checkLuaScriptResult` 方法

- 功能：检查 Lua 脚本的执行结果，并根据不同的状态码抛出对应的业务异常。
- 目的：统一处理 Lua 脚本的返回结果，提高代码的可读性和可维护性。

3.3. `buildLuaArgs` 方法

- 功能：构建 Lua 脚本的参数。
- 目的：将数据库中查询到的关注关系数据转换为 Lua 脚本需要的参数格式。
- 参数格式：
    - 每个关注关系需要两个参数：
        - 关注时间戳（作为 ZSET 的 score）。
        - 被关注用户的 ID（作为 ZSET 的 member）。
    - 最后一个参数是 ZSET 的过期时间。

4. Lua 脚本详解

4.1. `follow_check_and_add.lua`

- 功能：检查用户的关注数量是否达到上限、用户是否已经关注了目标用户，以及将新的关注关系添加到 Redis 缓存中。
- 实现步骤：
    1.  获取 Redis Key、被关注用户的 ID 和时间戳。
    2.  使用 `EXISTS` 命令检查 ZSET 是否存在。如果不存在，则返回 -1。
    3.  使用 `ZCARD` 命令检查用户的关注数量是否达到上限。如果达到上限，则返回 -2。
    4.  使用 `ZSCORE` 命令检查用户是否已经关注了目标用户。如果已经关注，则返回 -3。
    5.  使用 `ZADD` 命令将新的关注关系添加到 ZSET 中。
    6.  返回 0，表示关注成功。

4.2. `follow_add_and_expire.lua`

- 功能：将新的关注关系添加到 Redis 缓存中，并设置过期时间。
- 实现步骤：
    1.  获取 Redis Key、被关注用户的 ID、时间戳和过期时间。
    2.  使用 `ZADD` 命令将新的关注关系添加到 ZSET 中。
    3.  使用 `EXPIRE` 命令设置 ZSET 的过期时间。
    4.  返回 0，表示操作成功。

4.3. `follow_batch_add_and_expire.lua`

- 功能：批量将数据库中的关注关系数据同步到 Redis 缓存中，并设置过期时间。
- 实现步骤：
    1.  获取 Redis Key。
    2.  遍历所有的关注关系数据，将每个关注关系的时间戳和被关注用户的 ID 添加到一个数组中。
    3.  使用 `ZADD` 命令批量将关注关系数据添加到 ZSET 中。
    4.  使用 `EXPIRE` 命令设置 ZSET 的过期时间。
    5.  返回 0，表示操作成功。

5. 总结

`RelationServiceImpl` 通过缓存优先、原子性保证、多层校验等策略，实现了高性能、高可靠的用户关注服务。该服务的设计充分考虑了并发场景下的数据一致性问题，并使用了 Redis 和 Lua 脚本等技术来优化性能。

6. TODO

- 实现数据库的异步更新。
- 根据用户类型设置不同的缓存过期时间。
- 发送消息队列通知其他服务。

解释一下最后发送 MQ 的逻辑：
首先，构建消息体 DTO 实体类；
构建 Message 消息对象，并将 DTO 转成 Json 字符串设置到消息体中；
要想为 MQ 消息打上标签，可以在主题 Topic 的后面，通过冒号 : 连接, 携带上标签 Tag 的名称；
asyncSend() 是异步发送 MQ, SendCallback 为回调方法，提供了发送成功和异常两个方法；

首先，校验用户是否取关的是自己，不允许取关自己；
接着校验关注的用户是否存在；
然后，校验必须是关注了的用户，才能被取关。可通过 ZSCORE 命令来校验，检查被取关用户是否在个人的关注列表中；
若已在自己的关注列表中，则将其删除；
构建消息体 DTO，并异步发送 MQ, 让消费者去删除数据库的关系数据，接口直接返回操作成功；

先判断 Redis 是否有数据，有则通过缓存来判断；
否则，从数据库查询当前用户的关注关系记录：
若记录为空，则表示还未关注任何人，抛出业务异常，提示用户 “你未关注对方，无法取关”；
若记录不为空，则将关注关系数据全量同步到 Redis 中，并设置过期时间，再次判断用户是否关注 “取关的目标用户”；

分页：若 Redis 中没有数据，则从数据库查询，其逻辑处理如下：

   通过 selectCountByUserId() 查询关注列表总量；
   判断请求的页码是否超出了总页数；
   若没有，计算查询页码的偏移量，进行分页查询；
   提取所有关注用户 ID 到集合中;
   调用用户服务，并将 DTO 转换为 VO； (这部分逻辑比较通用，可以单独抽个方法 rpcUserServiceAndDTO2VO())
   异步将关注列表全量同步到 Redis 中；
   返回分页结果；
